<h1>How To Nitpick</h1>
<p><b>A practical guide to providing better feedback on solutions to exercises.</b></p>

<p>When reviewing exercism submissions, it is possible and encouraged to share advice and insight on the style and approach of a given implementation.</p>

<p>Nitpicks should provide positive and constructive criticism, subtly nudging a coder toward progressively better implementations of an exercise.</p>

<p>Consider it an opportunity to explore the subtleties of a particular coding problem.</p>

<p>Instead of outright suggesting an altogether different implementation, consider instead giving suggestions of small adjustments or refactorings to evolve the design and style of the existing code toward a more ideal implementation, by some definition of ideal.</p>

<p>In most cases, our idea of ideal code is simple, readable, maintainable, and modular.</p>

<p>Consider it an opportunity to discuss different coding practices and the value they provide in the context of crafting better software.</p>

<p>For example, with Bob (in Ruby) people often:</p>

<ul>
  <li>
    Use a regex to figure out if the string ends with a question mark.
    <br>A good nitpick response to this might be something like <em>"Have you considered using String#end_with? instead?"</em>
  </li>
  <li>
    Use a complicated regex to figure out if the input is "shouting".
    <br>
    An appropriate nitpick might be to encourage them to think about upcasing the input and checking it against the original.
  </li>
  <li>
  Leave all the fiddly implementation details for deciding how to respond in plain sight.
    <br>
  You might suggest that they create clearly named private methods to hide the implementation details, and tell us about what's actually happening, like asking or yelling.
  </li>
</ul>

<p>Please note that <em>good job</em> or <em>great work</em> are not positive, constructive feedback. If there is something you like about a solution, be specific when describing it.</p>

<p>Our goal is to collect a set of explanations for why a given solution might be more desirable (or undesirable, in this context), and share them where appropriate. Ultimately, we hope to converge on sets of theoretically ideal implementations to a given exercise, and provide justification for why it is an exemplary approach in a particular context. For example, we might have a "most readable" implementation, a "simplest" implementation, and a "fastest" implementation, along with explanations for when each would be preferable.</p>

<p>When leaving nitpicks, please remember that beginners do not always have the same confidence level as more experienced developers. It is therefore important to be courteous and considerate. Strive to be clear in your explanations and give users a chance to arrive at their own improvements. Might the Socratic Method be a suitable approach?</p>

<blockquote>
A rising tide lifts all the boats.
<cite>- Unknown</cite>
</blockquote>
